package analizadorLexico;
/*
El archivo main muestra una ventana con los datos leidos del archivo, una vez hecho click en analizar, genera el archvio salida.txt
y muestra al mismo tiempo el resultado en la misma ventana del formulario.

La ventana entrada del fomulario permite hacer cambios en el fuente sin tener que modificar todo de nuevo.

Siempre que se le da a analizar, este reemplaza el archivo generado anteriormente.

*/
import static analizadorLexico.AnalizadorConstants.*;
import com.sun.org.apache.xpath.internal.compiler.OpCodes;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 *
 * @author Alejandro Ruiz Diaz
 *
 */
public class AnalizadorLexico extends javax.swing.JFrame {

  private int num_lineas = 0;
  // Estado actual.
  private int estado = 0;
  // Posición actual con respecto al editor.
  private int posicion = 0;
  // Representa el texto fuente del análisis.
  private String fuente = "";
  // Se analizará carácter por carácter el String fuente. 'caracter'
  // representará el simbolo.
  private char caracter;
  // Es el carácter o conjunto de caracteres que representan una 
  // acción, atributo, etc. en el lenguaje.
  private String lexema = "";
  // Lista completa de lexemas encontradas en el String fuente.
  private ArrayList<String> listaLexema = new ArrayList();
  // Indica que tipo de lexema se encuentra en la lista lexema.
  // los atributos estan ordenados: 
  // listaLexema(i) es de tipo listaToken(i)
  private ArrayList<String> listaToken = new ArrayList();
  Map<String, String> keys = new HashMap<String, String>();

  /**
   * Creates new form AnalizadorLexico
   */
  public AnalizadorLexico() {
    initComponents();
   
    //entradaFuente.setText("a = 1;\nb = 1;\na+b;");
    //Inicializa el hashMap
    keys.put(PR_IF, PR_IF);
    keys.put(PR_TRUE, PR_TRUE);
    keys.put(PR_FALSE, PR_FALSE);
    keys.put(PR_ALERT, PR_ALERT);
    keys.put(PR_NUM, PR_NUM);
    keys.put(PR_ID, PR_ID);
    keys.put(PR_LITERAL, PR_LITERAL);
    keys.put(PR_COMENTARIO, PR_COMENTARIO);

    String fuente_aux = "";
    FileReader fileReader = null;

    try {
      //Lee el archivo fuente y lo carga en el campo de texto de la aplicacion
      fileReader = new FileReader(new File("./fuente.txt"));
      BufferedReader bufferedReader = new BufferedReader(fileReader);
      String line;
      //fileReader = new FileReader("/tmp/fuente.txt");
      int c;
      while( (line = bufferedReader.readLine()) != null ) {
        System.out.println(line);
        fuente_aux += line+"\n";
      }
      //salidaFuente.setText(fuente_aux);
      entradaFuente.setText(fuente_aux);
    } catch( Exception e ) {
      e.printStackTrace();
    } finally {
      try {
        if( fileReader != null ) {
          fileReader.close();
        }
      } catch( Exception e2 ) {

        e2.printStackTrace();
      }
    }
    fuente = entradaFuente.getText();
    fuente = fuente.trim();
    if( fuente.length() == 0 ) {
      salidaFuente.setText("El cuadro de entrada no contiene\ncaracteres a evaluar. ");

    }
  }

  /**
   * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jFrame1 = new javax.swing.JFrame();
    jFrame2 = new javax.swing.JFrame();
    jScrollPane1 = new javax.swing.JScrollPane();
    salidaFuente = new javax.swing.JTextArea();
    jScrollPane2 = new javax.swing.JScrollPane();
    entradaFuente = new javax.swing.JTextArea();
    btn_analizar = new javax.swing.JButton();
    jLabel1 = new javax.swing.JLabel();
    jLabel2 = new javax.swing.JLabel();
    jLabel3 = new javax.swing.JLabel();

    javax.swing.GroupLayout jFrame1Layout = new javax.swing.GroupLayout(jFrame1.getContentPane());
    jFrame1.getContentPane().setLayout(jFrame1Layout);
    jFrame1Layout.setHorizontalGroup(
      jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
    );
    jFrame1Layout.setVerticalGroup(
      jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 300, Short.MAX_VALUE)
    );

    javax.swing.GroupLayout jFrame2Layout = new javax.swing.GroupLayout(jFrame2.getContentPane());
    jFrame2.getContentPane().setLayout(jFrame2Layout);
    jFrame2Layout.setHorizontalGroup(
      jFrame2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
    );
    jFrame2Layout.setVerticalGroup(
      jFrame2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 300, Short.MAX_VALUE)
    );

    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

    salidaFuente.setColumns(20);
    salidaFuente.setRows(5);
    salidaFuente.setDisabledTextColor(new java.awt.Color(2, 159, 20));
    salidaFuente.setEnabled(false);
    jScrollPane1.setViewportView(salidaFuente);

    entradaFuente.setColumns(20);
    entradaFuente.setRows(5);
    jScrollPane2.setViewportView(entradaFuente);

    btn_analizar.setText("Analizar");
    btn_analizar.addMouseListener(new java.awt.event.MouseAdapter() {
      public void mouseReleased(java.awt.event.MouseEvent evt) {
        btn_analizarMouseReleased(evt);
      }
    });

    jLabel1.setFont(new java.awt.Font("Ubuntu", 1, 15)); // NOI18N
    jLabel1.setText("Entrada");

    jLabel2.setFont(new java.awt.Font("Ubuntu", 1, 15)); // NOI18N
    jLabel2.setText("Salida");

    jLabel3.setFont(new java.awt.Font("Bitstream Vera Sans", 1, 18)); // NOI18N
    jLabel3.setText("Analizador lexico basico");

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addGap(110, 110, 110)
        .addComponent(jLabel1)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        .addComponent(jLabel2)
        .addGap(140, 140, 140))
      .addGroup(layout.createSequentialGroup()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(layout.createSequentialGroup()
            .addGap(189, 189, 189)
            .addComponent(jLabel3))
          .addGroup(layout.createSequentialGroup()
            .addContainerGap()
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 280, Short.MAX_VALUE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(btn_analizar, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 308, Short.MAX_VALUE)))
        .addContainerGap())
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addComponent(jLabel3)
        .addGap(32, 32, 32)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel1)
          .addComponent(jLabel2))
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(layout.createSequentialGroup()
            .addGap(24, 24, 24)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
              .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(jScrollPane2))
            .addGap(17, 17, 17))
          .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 111, Short.MAX_VALUE)
            .addComponent(btn_analizar, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addGap(108, 108, 108))))
    );

    pack();
  }// </editor-fold>//GEN-END:initComponents

  private void btn_analizarMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btn_analizarMouseReleased
    //Al presionar el boton analizar, comienza el proceso de analisis letra por letra
    estado = 0;
    posicion = 0;
    lexema = "";
    listaLexema.clear();
    listaToken.clear();
    fuente = entradaFuente.getText();
    fuente = fuente.trim();

    if( fuente.length() == 0 ) {
      salidaFuente.setText("El cuadro de entrada no contiene\n caracteres a evaluar. ");
    } else {
      num_lineas = 1;
      //addList("", "LINEA N°::::::::::::::::::::::::::::::: " + num_lineas + "\n");
      iniciarProceso();
      imprimirLista();
    }
  }//GEN-LAST:event_btn_analizarMouseReleased

  /**
   * Método principal del proceso de verificación de tokens, cambia de estados dependiendo del caracter encontrado, en el estado cero no cambia de
   * estado con los caracteres +, =, ; los toma como signos de aceptación (unicamente los agrega al listado de lexemas). El cambio de estado se
   * realiza cuando en el estado cero aparecen los caracteres número o de 'a' to 'z'.
   */
  private void iniciarProceso() {
    caracter = fuente.charAt(posicion);
    switch( estado ) {
      case 0: {
        /**
         * En este estado el lexema actual esta vacío. Si se obtiene como carácter actual ';', '+' o '=' no cambia de estado debido a que estos
         * simbolos son de aceptación, entonces, se agregan a la lista de lexemas, y se vuelve a iniciar el proceso. Si obtiene un caracter de tipo
         * vacío no realiza ningún cambio de estados, solo reinicia el proceso. para los dígitos o letras. Se realiza el cambio de estado que
         * corresponde con el automata.
         */
        if( caracter == OP_PUNTOYCOMA ) {
          lexema += Character.toString(caracter);
          addList(lexema, "punto y coma");
          lexema = "";
        }else if( esCadenaString(caracter)) {
                    
          lexema = "";
        } else if( caracter == OP_MAS ) {
          lexema += Character.toString(caracter);
          addList(lexema, "mas");
          lexema = "";
        } else if( caracter == OP_MENOS ) {
          //Verificar que no sea DELIMITADOR_CODIGO (->)
          if( fuente.charAt(posicion + 1) == '>' ) {
            //Es DELIMITADOR_CODIGO
            addList("->", "DELIMITADOR_CODIGO");
            posicion++;
          } else {
            //Es OP MENOS
            lexema += Character.toString(caracter);
            addList(lexema, "menos");
          }
          lexema = "";
        } else if( caracter == OP_DIV ) {
          lexema += Character.toString(caracter);
          addList(lexema, "division");
          lexema = "";
        } else if( caracter == OP_COMA ) {
          lexema += Character.toString(caracter);
          addList(lexema, "coma");
          lexema = "";
        } else if( caracter == OP_CONDICION ) {
          lexema += Character.toString(caracter);
          addList(lexema, "op_condicion");
          lexema = "";
        } else if( caracter == PARENTESIS_IZQ ) {
          lexema += Character.toString(caracter);
          addList("(", "parentesis_izq");
          lexema = "";
        } else if( caracter == PARENTESIS_DER ) {
          lexema += Character.toString(caracter);
          addList(")", "parentesis_der");
          lexema = "";
        } else if( caracter == CORCHETE_IZQ ) {
          lexema += Character.toString(caracter);
          addList("[", "corchete_izq");
          lexema = "";
        } else if( caracter == CORCHETE_DER ) {
          lexema += Character.toString(caracter);
          addList("]", "corchete_der");
          lexema = "";
        } else if( caracter == OP_MULTIPLICACION ) {
          lexema += Character.toString(caracter);
          addList("*", "op_multiplicacion");
          lexema = "";
        } else if( caracter == OP_ASIGNACION ) {
          if( fuente.charAt(posicion + 1) == OP_ASIGNACION ) {
            //Es op de comparacion
            addList(OP_COMPARACION, "op_comparacion");
          } else {
            //Es op de asignacion
            lexema += Character.toString(caracter);
            addList(lexema, "operador igual");
          }
          lexema = "";
        } else if( caracter == OP_REL_MENOR_QUE ) {
          //es un operador relacional, averiguar cual
          posicion++;
          char c = fuente.charAt(posicion);
          if( c == OP_REL_MAYOR_QUE ) {
            addList("<>", "operador relacional");
          } else if( c == OP_ASIGNACION ) {
            addList("<=", "operador relacional");
          } else {
            posicion--;
            addList("<", "operador relacional");
          }
          lexema = "";

        } else if( caracter == OP_REL_MAYOR_QUE ) {
          //es un operador relacional, averiguar cual
          posicion++;
          char c = fuente.charAt(posicion);
          if( c == OP_ASIGNACION ) {
            addList(">=", "operador relacional");
          } else {
            posicion--;
            addList(">", "operador relacional");
          }
          lexema = "";

        } else if( Character.isDigit(caracter) ) {
          estado = 5;
          lexema += Character.toString(caracter);
        } else if( Character.isLetter(caracter) ) {
          estado = 1;
          lexema += Character.toString(caracter);
        } else if( esEspacio(caracter) ) {
        } else if( esEnter(caracter) ) {
          lexema += Character.toString(caracter);
          addList("\\n", "enter");
          lexema = "";
          addList("", "\n");
        } else if( esComentario(caracter) ) {
          //lexema += Character.toString(caracter);
          
          lexema = "";
        } else {
          addList("", " Error, caracter no valido! ");
          error();
        }
        break;
      }
      case 1: {
        /**
         * Estado 1, inicia cuando se encuentra una letra.
         */
        if( caracter == OP_PUNTOYCOMA ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, "palabra_reservada");
          } else {
            addList(lexema, "identificador");
          }
          addList(";", "punto y coma");
          estado = 0;
          lexema = "";
        }else if( esCadenaString(caracter)) {                   
          lexema = "";
          estado = 0;
        } else if( caracter == OP_COMA ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList(",", "coma");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_DIV ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("/", "division");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_CONDICION ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("?", "op_condicion");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_ASIGNACION ) {
          if( fuente.charAt(posicion + 1) == OP_ASIGNACION ) {
            //Es op de comparacion
            if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
              addList(lexema, keys.get(lexema));
            } else {
              addList(lexema, "identificador");
            }
            addList("==", "op_comparacion");
            estado = 0;
            lexema = "";
            posicion++;
          } else {
            //Es op de asignacion
            if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
              addList(lexema, keys.get(lexema));
            } else {
              addList(lexema, "identificador");
            }
            addList("=", "igual");
            estado = 0;
            lexema = "";
          }

        } else if( caracter == OP_REL_MENOR_QUE ) {
          //es un operador relacional, averiguar cual
          posicion++;
          char c = fuente.charAt(posicion);
          if( c == OP_REL_MAYOR_QUE ) {
            if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
              addList(lexema, keys.get(lexema));
            } else {
              addList(lexema, "identificador");
            }
            addList("<>", "operador relacional");
          } else if( c == OP_ASIGNACION ) {
            if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
              addList(lexema, keys.get(lexema));
            } else {
              addList(lexema, "identificador");
            }
            addList("<=", "operador relacional");
          } else {
            posicion--;
            if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
              addList(lexema, keys.get(lexema));
            } else {
              addList(lexema, "identificador");
            }
            addList("<", "operador relacional");
          }
          lexema = "";
          estado = 0;

        } else if( caracter == OP_REL_MAYOR_QUE ) {
          //es un operador relacional, averiguar cual
          posicion++;
          char c = fuente.charAt(posicion);
          if( c == OP_ASIGNACION ) {
            if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
              addList(lexema, keys.get(lexema));
            } else {
              addList(lexema, "identificador");
            }
            addList(">=", "operador relacional");
          } else {
            posicion--;
            if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
              addList(lexema, keys.get(lexema));
            } else {
              addList(lexema, "identificador");
            }
            addList(">", "operador relacional");
          }
          lexema = "";
          estado = 0;

        } else if( caracter == OP_MAS ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("+", "mas");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_MENOS ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList(lexema, "menos");
          estado = 0;
          lexema = "";
        } else if( caracter == PARENTESIS_IZQ ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("(", "parentesis_izq");
          estado = 0;
          lexema = "";
        } else if( caracter == PARENTESIS_DER ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList(")", "parentesis_der");
          estado = 0;
          lexema = "";
        } else if( caracter == CORCHETE_IZQ ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("[", "corchete_izq");
          estado = 0;
          lexema = "";
        } else if( caracter == CORCHETE_DER ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("]", "corchete_der");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_MULTIPLICACION ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("*", "op_multiplicacion");
          estado = 0;
          lexema = "";
        } else if( esEspacio(caracter) ) {
           if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
            estado = 0;
            lexema = "";
          }
        } else if( esEnter(caracter) ) {
          if( keys.containsValue(lexema) ) { //Si es true, es palabra reservada
            addList(lexema, keys.get(lexema));
          } else {
            addList(lexema, "identificador");
          }
          addList("\\n", "enter");
          estado = 0;
          lexema = "";
          addList("", "\n");
        } else if( Character.isDigit(caracter) || Character.isLetter(caracter) ) {
          lexema += Character.toString(caracter);
        } else {
          addList("", " Error mientras se analizaba una cadena! ");
          error();
        }
        //imprimir();
        break;
      }
      case 5: {
        /**
         * Estado 5, inicia cuando se encuentra un digito.
         */
        if( caracter == OP_PUNTOYCOMA ) {
          addList(lexema, "numero");
          addList(";", "punto y coma");
          lexema = "";
          estado = 0;
        } else if( caracter == OP_COMA ) {
          addList(lexema, "numero");
          addList(",", "coma");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_CONDICION ) {
          addList(lexema, "numero");
          addList("?", "op_condicion");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_DIV ) {
          addList(lexema, "numero");
          addList("/", "op_division");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_ASIGNACION ) {
          if( fuente.charAt(posicion + 1) == OP_ASIGNACION ) {
            //Es op de comparacion
            addList(lexema, "numero");
            addList("==", "op_comparacion");
            posicion++;
            lexema = "";
            estado = 0;

          } else {
            //Es op de asignacion
            addList(lexema, "numero");
            addList("=", "igual");
            estado = 0;
            lexema = "";
          }

        } else if( caracter == OP_REL_MENOR_QUE ) {
          //es un operador relacional, averiguar cual
          posicion++;
          char c = fuente.charAt(posicion);
          if( c == OP_REL_MAYOR_QUE ) {
            addList(lexema, "numero");
            addList("<>", "operador relacional");
          } else if( c == OP_ASIGNACION ) {
            addList(lexema, "numero");
            addList("<=", "operador relacional");
          } else {
            posicion--;
            addList(lexema, "numero");
            addList("<", "operador relacional");
          }
          lexema = "";
          estado = 0;

        } else if( caracter == OP_REL_MAYOR_QUE ) {
          //es un operador relacional, averiguar cual
          posicion++;
          char c = fuente.charAt(posicion);
          if( c == OP_ASIGNACION ) {
            addList(lexema, "numero");
            addList(">=", "operador relacional");
          } else {
            posicion--;
            addList(lexema, "numero");
            addList(">", "operador relacional");
          }
          lexema = "";
          estado = 0;

        } else if( caracter == OP_MAS ) {
          addList(lexema, "numero");
          addList("+", "mas");
          lexema = "";
          estado = 0;
        } else if( caracter == OP_MENOS ) {
          addList(lexema, "numero");
          addList(lexema, "menos");
          estado = 0;
          lexema = "";
        } else if( caracter == PARENTESIS_IZQ ) {
          addList(lexema, "numero");
          addList("(", "parentesis_izq");
          estado = 0;
          lexema = "";
        } else if( caracter == PARENTESIS_DER ) {
          addList(lexema, "numero");
          addList(")", "parentesis_der");
          estado = 0;
          lexema = "";
        } else if( caracter == CORCHETE_IZQ ) {
          addList(lexema, "numero");
          addList("[", "corchete_izq");
          estado = 0;
          lexema = "";
        } else if( caracter == CORCHETE_DER ) {
          addList(lexema, "numero");
          addList("]", "corchete_der");
          estado = 0;
          lexema = "";
        } else if( caracter == OP_MULTIPLICACION ) {
          addList(lexema, "numero");
          addList("*", "op_multiplication");
          estado = 0;
          lexema = "";
        } else if( esEspacio(caracter) ) {
          
        }else if( Character.isLetter(caracter) ) {
          addList(lexema, "numero");  
          lexema = "";
          lexema += Character.toString(caracter);
          
          estado = 1;
        } else if( esEnter(caracter) ) {
          addList(lexema, "numero");
          addList("\\n", "enter");
          lexema = "";
          estado = 0;
          addList("", "\n");
        } else if( Character.isDigit(caracter) ) {          
          lexema += Character.toString(caracter);

        } else {
          addList("", " Error mientras se analizaba un numero! ");
          error();
        }
        break;
      }
      default:
        break;
    }
    /**
     * Al finalizar el análisis con el carácter actual se toma la posición siguiente y se repite el análisis hasta llegar al punto final del String
     * fuente.
     */
    posicion++;
    //imprimir();
    if( posicion >= fuente.length() ) {
      if( estado == 1 ) {
        addList(lexema, "identificador");
      } else if( estado == 5 ) {
        addList(lexema, "numero");
      }

    } else {
      iniciarProceso();
    }
  }

  /**
   * Llamado cuando se encuentra un error en la entrada. Se llama el mismo hasta que encuentra un caracter limitador.
   */
  private void error() {
    lexema += Character.toString(caracter);
    posicion++;
    if( posicion >= fuente.length() ) {
      estado = 0;
    } else {
      caracter = fuente.charAt(posicion);
      if( caracter == OP_ASIGNACION ) {
        //addList(lexema, "error");
        addList("=", "igual");
        estado = 0;
        lexema = "";
      } else if( caracter == OP_COMA ) {
        //addList(lexema, "error");
        addList(",", "coma");
        estado = 0;
        lexema = "";
      } else if( caracter == OP_CONDICION ) {
        //addList(lexema, "error");
        addList("?", "op_condicion");
        estado = 0;
        lexema = "";
      } else if( caracter == OP_MAS ) {
        //addList(lexema, "error");
        addList("+", "suma");
        estado = 0;
        lexema = "";
      } else if( caracter == OP_MENOS ) {
        //addList(lexema, "error");
        addList("-", "menos");
        estado = 0;
        lexema = "";
      } else if( caracter == OP_PUNTOYCOMA ) {
        //addList(lexema, "error");
        addList(";", "punto y coma");
        estado = 0;
        lexema = "";
      } else if( caracter == PARENTESIS_IZQ ) {
        //addList(lexema, "error");
        addList(lexema, "parentesis_izq");
        lexema = "";
      } else if( caracter == PARENTESIS_DER ) {
        //addList(lexema, "error");
        addList(lexema, "parentesis_der");
        lexema = "";
      } else if( caracter == CORCHETE_IZQ ) {
        //addList(lexema, "error");
        addList(lexema, "corchete_izq");
        lexema = "";
      } else if( caracter == CORCHETE_DER ) {
        //addList(lexema, "error");;
        addList(lexema, "corchete_der");
        lexema = "";
      } else if( esEspacio(caracter) ) {
        //addList(lexema, "error");
        estado = 0;
        lexema = "";
      } else if( esEnter(caracter) ) {
        //addList(lexema, "error");
        addList("\\n", "enter");
        estado = 0;
        lexema = "";
        addList("", "\n");
      } else {

        error();
      }
    }
  }

  /**
   * Analiza los espacios, enter, comentario
   */
  private boolean esEspacio( char c ) {
    boolean flag = false;
    if( c == '\t' || c == ' ' ) {
      flag = true;
    }
    return flag;
  }

  /*Salto de linea*/
  private boolean esEnter( char c ) {
    boolean flag = false;
    if( c == '\n' ) {
      num_lineas++;
      flag = true;
    }
    return flag;
  }

  //Comentario
  private boolean esComentario( char c ) {
    boolean flag = false;
    if( c == '#' ) {
      c = fuente.charAt(posicion);
      while( !esEnter(c) && (posicion < fuente.length()) ) {
        c = fuente.charAt(posicion);
        posicion++;
      }
      addList("#", "comentario");
      if( esEnter(c) ) {
        addList("\\n", "enter");
        addList("", "\n");
        num_lineas++;
      } else {
        addList("eof", "fin de archivo");
      }
      posicion--;
      
      return true;
    }
    return flag;
  }
  
  private boolean esCadenaString(char c){
    if( c == OP_COMILLA ) {
      posicion++;
      c = fuente.charAt(posicion);
      while( c != OP_COMILLA && (posicion < fuente.length()) ) {
        c = fuente.charAt(posicion);
        posicion++;
      }
      
      if( c == OP_COMILLA ) {
        addList("", "LITERAL_CADENA");
      } else {
        if(posicion < fuente.length()){
          addList("error","Error, Literal cadena esperaba cierre de comillas");
          addList("EOF","Fin de archivo");
        }else{
          addList("error","Error, Literal cadena esperaba cierre de comillas");
        }
      }
      posicion--;      
      return true;
    }
    return false;
  }

  /**
   * destino: representa el textArea en el que se mostrarán los resultados obtenidos. Imprime en el textArea 'destino' la lista de tokens y sus
   * lexemas. Luego tambien imprime en un archivo de texto
   */
  private void imprimirLista() {
    String auxiliar = "Resultado del analisis\n";
    for( int i = 0; i < listaLexema.size(); i++ ) {
      //auxiliar += listaToken.get(i) + "  \t\t  " + listaLexema.get(i) + "\n";
      auxiliar += listaToken.get(i) + "  ";
    }
    salidaFuente.setText(auxiliar);
    /*Escribir en archivo*/
    File f;
    f = new File("./salida.txt");

    //Escritura
    try {
      FileWriter w = new FileWriter(f);
      BufferedWriter bw = new BufferedWriter(w);
      PrintWriter wr = new PrintWriter(bw);
      wr.write(auxiliar);//escribimos en el archivo 

      wr.close();
      bw.close();
    } catch( IOException e ) {
    };

  }

  /**
   * imprime en consola el estado, caracter, lexema y posicion actual.
   */
  private void imprimir() {
    System.out.println("estado:" + estado + " caracter:" + caracter + " lexema:"
      + lexema + " posicion:" + posicion);
  }

  /**
   *
   * @param lex
   * @param token agrega lex y token a la lista de lexemas y tokens.
   */
  private void addList( String lex, String token ) {
    listaLexema.add(lex);
    listaToken.add(token);
  }

  /**
   * @param args the command line arguments
   */
  public static void main( String args[] ) {
    /* Set the Nimbus look and feel */
    //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
     * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
     */
    try {
      for( javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels() ) {
        if( "Nimbus".equals(info.getName()) ) {
          javax.swing.UIManager.setLookAndFeel(info.getClassName());
          break;
        }
      }
    } catch( ClassNotFoundException ex ) {
      java.util.logging.Logger.getLogger(AnalizadorLexico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch( InstantiationException ex ) {
      java.util.logging.Logger.getLogger(AnalizadorLexico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch( IllegalAccessException ex ) {
      java.util.logging.Logger.getLogger(AnalizadorLexico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch( javax.swing.UnsupportedLookAndFeelException ex ) {
      java.util.logging.Logger.getLogger(AnalizadorLexico.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    //</editor-fold>

    /* Create and display the form */
    java.awt.EventQueue.invokeLater(new Runnable() {
      public void run() {
        AnalizadorLexico analizador =  new AnalizadorLexico();
        analizador.setVisible(true);
        analizador.setExtendedState(MAXIMIZED_BOTH);
        
      }

    });
  }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton btn_analizar;
  private javax.swing.JTextArea entradaFuente;
  private javax.swing.JFrame jFrame1;
  private javax.swing.JFrame jFrame2;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JLabel jLabel2;
  private javax.swing.JLabel jLabel3;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JScrollPane jScrollPane2;
  private javax.swing.JTextArea salidaFuente;
  // End of variables declaration//GEN-END:variables
}
